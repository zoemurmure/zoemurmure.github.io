<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Logic Security 逻辑门</title>
    <link>https://www.zoemurmure.top/</link>
    <description>Recent content on Logic Security 逻辑门</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 21 Apr 2023 09:52:44 +0800</lastBuildDate><atom:link href="https://www.zoemurmure.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CVE-2023-21768 AFD for WinSock 提权漏洞利用思路探索</title>
      <link>https://www.zoemurmure.top/posts/cve_2023_21768/</link>
      <pubDate>Fri, 21 Apr 2023 09:52:44 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/cve_2023_21768/</guid>
      <description>1. 前言 这篇文章分析了 CVE-2023-21768 漏洞，该漏洞存在于 Windows 操作系统的 AFD 驱动程序中。文章中原文指代参考链接[1]的文章，通过对该篇文章的学习，我复现并重新编写了 exploit 代码，同时根据他人在编写漏洞利用程序时的步骤，分析自己的不足之处。
文章中涉及漏洞基础分析、漏洞触发尝试(poc)、漏洞利用实现三个主要部分，同时对漏洞利用时涉及到的 I/O Ring 知识点做了简单介绍。
2. 补丁对比 通过补丁对比确定漏洞修复函数为 AfdNotifyRemoveIoCompletion，修复点增加了对于某个结构字段是否可写的检查，然后才执行赋值操作：
也就是说，漏洞未修复前，该字段可能被攻击者控制，从而写入到其他位置。
原文首先进行的是补丁对比，这是进行 Windows 漏洞分析的基本操作，如果没有其他信息，也是我在漏洞分析时会首先进行的步骤。补丁对比通常可以确定修复函数的位置，同时获取关于漏洞的一些信息。
在对修复前后的 afd.sys 文件进行对比后，发现只有一个函数进行了细微的改动，这种情况是比较幸运的，因为通常会发现存在多个函数被修改，而且改动幅度也可能很大，如果没有其他信息，很难确定漏洞究竟发生在哪个位置。
3. 交叉引用检查 根据上一小节的结论，可被攻击者控制的字段 a3 + 24 是函数 AfdNotifyRemoveIoCompletion 的第三个参数中的字段，也就是说第三个参数是一个未知结构体。
接下来检查 AfdNotifyRemoveIoCompletion 的交叉引用，看一下这个参数的来源：
.rdata:00000001C004D658 dq offset AfdNotifySock .rdata:00000001C004D660 AfdIrpCallDispatch dq offset AfdBind → AfdNotifySock(__int64 a1, __int64 a2, KPROCESSOR_MODE a3, ULONG64 a4, int a5, __int64 a6, int a7) → AfdNotifyRemoveIoCompletion(a3, v1, a4) 也就是说，AfdNotifyRemoveIoCompletion 的第三个参数是 AfdNotifySock 的第四个参数，而 AfdNotifySock 位于 AfdIrpCallDispatch 的上面。</description>
    </item>
    
    <item>
      <title>Win32k 类型混淆漏洞分析指南</title>
      <link>https://www.zoemurmure.top/posts/win32k_1732_21881/</link>
      <pubDate>Tue, 07 Feb 2023 14:25:08 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/win32k_1732_21881/</guid>
      <description>0. 前言 众所周知，win32k 在近几年为 Windows 提权漏洞贡献了很多力量，我也一直想搞清楚这类漏洞的原理，为此看了很多相关论文。但是作为一个内核漏洞研究的菜鸟，大佬们写的 win32k 漏洞的 write-up 在我看来还是和天书一样。
当然，我知道什么是 UAF，什么是类型混淆，我也知道 win32k 的很多漏洞都是由于回调函数导致的，可是当所有的这些概念组合在一起，再加上一些专业名词还有很长的函数名称，事情就完全不同了。
为此，我想通过对 CVE-2021-1732 和 CVE-2022-21881 这两个漏洞的分析，复盘自己在面对此类漏洞时遇到的困惑，并尝试进行解决，这样以后再遇到 win32k 的漏洞时，可以有的放矢，迅速解决问题。
1. 基础知识 1.1 基础建设 在没有接触 win32k 之前，我对于系统调用的理解，无非就是应用程序调用 DLL 文件中某个函数，从而实现某个系统功能，如果需要内核的参与，DLL 文件会自己处理关于内核的问题。而每个 DLL 文件就是一些具有关联性的功能的合集。
当我尝试了解 win32k 的时候，被告诉的第一个事实就是，win32k 主要处理 Windows GUI 相关的问题，作为一个日常使用 GUI 系统的普通用户，我会有一个下意识的错误观念 —— GUI 即一切，所以当时我的第一反应就是：怎么可能所有的功能都放到了一个文件里？
但是如果仔细思考，或者去看一下 C:/Windows/System32 目录下的 DLL 文件，会发现 Windows 的功能太多了，通信、加密、邮件、浏览器……我之所以会认为 GUI 即一切，是因为很多功能最终都会通过 GUI 反应到使用者的视觉中，因此可以这样理解，win32k 是其他功能的基石，其他功能或多或少的需要 win32k 中的功能。实际上，除了 win32k 之外，还有 csrss，两者共同构成了 win32 子系统，关于这一点可以看我之前的文章CSRSS 基础知识的历史背景部分。
1.2 用户态 GUI 知识点 建议所有对 win32k 有疑惑的朋友都先看一下 Programming Windows 第五版的第三章 Windows and Messages，我在读大学的时候曾经从编程的角度看过这本书的一部分内容，但是现在回过头来再读，还是发现了很多自己遗漏的细节。</description>
    </item>
    
    <item>
      <title>[CVE-2023-21752] Windows Backup Service 本地提权漏洞分析</title>
      <link>https://www.zoemurmure.top/posts/cve_2023_21752_1/</link>
      <pubDate>Tue, 17 Jan 2023 19:06:30 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/cve_2023_21752_1/</guid>
      <description>0. 前言 CVE-2023-21752 是 2023 年开年微软第一个有 exploit 的漏洞，原本以为有利用代码会很好分析，但是结果花费了很长时间，难点主要了两个：漏洞点定位和漏洞利用代码分析，因此在本文中花费了更多的篇幅介绍了这两部分内容，欢迎指正。
1. 漏洞简介 根据官方信息，该漏洞是 Windows Backup Service 中的权限提升漏洞，经过身份认证的攻击者可利用此漏洞提升至 SYSTEM 权限。成功利用此漏洞需要攻击者赢得竞争条件。
EXP 代码位于 Github，提供了两个版本，版本 1 可以实现任意文件删除，可稳定复现；版本 2 尝试利用任意删除实现本地提权，但是复现不稳定。
2. 漏洞点定位的曲折之路 这部分内容是一些失败的过程记录，以及我自己的碎碎念，防止自己之后犯同样的错误，只对漏洞分析感兴趣的可以略过 2.1 和 2.3 小节。
2.1 失败的过程 首先尝试复现，提权版本的利用程序在虚拟机上没有复现成功，任意文件删除版本的利用程序由于我没有使用完整路径，也没有复现成功（但是此时我还不知道原因）。
之后我尝试进行补丁对比，但是想要进行补丁对比首先要确定漏洞位于哪个文件中，根据漏洞利用程序的文件命名 SDRsvcEop，找到了文件 sdrsvc.dll，但是补丁对比后并没有发现差异。
这期间我还搜索了关于这个漏洞的信息，但是除了漏洞通告和 GitHub 的 exp 代码外，没有找到其他内容。这里吐槽一下某数字站的漏洞通告，竟然说这个漏洞是 Windows Server Backup (WSB) 上的……
这个时候我已经开始对漏洞利用代码进行分析了，一方面通过微软的文档，了解代码中一些函数和参数的使用，一方面开始在 Windbg 上进行调试，并由此找到了 rpcrt4.dll、combase.dll 这些和漏洞无关的文件。
在调试过程中，我花费了很多时间在 DeviceIoControl 这个函数上，因为之前看的很多漏洞最终定位的文件都是 sys 驱动文件，因此虽然我在心里仍旧为 dll 文件留了一些位置，但是在方法选择上，我仍旧趋向去寻找某个 sys 文件。所以我想要在利用程序执行到 DeviceIoControl 的时候，在用户态转内核态的入口位置设置一个断点，然后监控系统究竟执行到了哪里。当然，这个方法失败了，并且搞得我心烦意乱。
我在这个时候才想起来要把利用程序参数的相对路径改成绝对路径，并且成功复现了任意文件删除。虽然但是，这之后我又走了弯路……
之前学习病毒分析的时候，有一个算是标准的流程，就是要先执行病毒，看一下它的动态特征，以此方便后面的动态分析。之前看的很多漏洞分析文章，也都是要执行一下 poc 或者 exp，进行进程监控，但是我完全忘记了，或者说我虽然想到了这个方法，但是并没有十分重视。
我在继续分析漏洞利用代码，在此期间看了一些关于 DCOM 的资料，确定 sdrsvc.</description>
    </item>
    
    <item>
      <title>CSRSS 基础知识</title>
      <link>https://www.zoemurmure.top/posts/csrss_base/</link>
      <pubDate>Tue, 10 Jan 2023 17:07:41 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/csrss_base/</guid>
      <description>0. 前言 这是一篇不完整的 csrss 介绍，因为前段时间在看 csrss 相关的漏送，所以对相关的知识做了一下整理，因此你无法只通过这篇文章完全了解 csrss，但是如果这篇文章能够解答你在学习 csrss 时的一些疑惑，那么它的目的就达成了。
1. 历史背景 1.1 微内核(microkernel)的概念 微内核指一个现代化、模块化操作系统中最核心的部分，微内核操作系统有两个原则：
模块化、封装性和数据隐藏。即操作系统中有且仅有一部分对一个特定功能具有系统范围内的责任，操作系统中的其他部分，包括应用程序只能通过定义好的接口对使用该功能； 操作系统中的大部分功能在用户/应用程序模式下执行，只有微内核本身及硬件相关的小部分代码在内核态下执行。 遵循以上两个原则的操作系统叫做纯微内核系统，仅遵循第一个原则但不遵循第二个原则的操作系统叫做修改后的微内核(modified microkernel)或者宏内核(macrokernel)操作系统。商业性质的操作系统一般不会基于纯微内核进行设计，因为这样的架构计算成本太大。
Windows NT 就是修改后的微内核系统，具有非常好的模块化和封装性，另一方面，从最初版本开始，Windows NT 就在内核态实现了高性能操作系统子系统，这些子系统可以在内核模式下与硬件交互以及相互交互，而不会影响处理器模式以及进程/线程转换的性能。作为内核态子系统实现的有内存管理器、集成缓存管理器、文件系统、对象/安全管理器、网络协议、网络服务器以及所有的线程/进程管理。
然而在 Windows NT 4.0 之前，有一个领域一直采取纯微内核模式，也就是窗口管理器以及图形化子系统，它们用于实现 Win32 API 中的 GUI 部分。在 Windows NT 3.51 及之前的版本中，窗口管理器和 GDI 作为一个单独的用户态进程 Client-Server Subsystem(csrss.exe) 实现。
1.2 Win32 子系统 在 Windows NT 的最初设计阶段，Win32 被设计为等同于 OS/2、POSIX 以及其他计划中的操作系统环境。每个这样的子系统都作为一个独立的环境运行。但是这种设计会导致存在大量重复的系统功能，影响系统规模以及性能。为了避免重复，以及响应市场趋势，最终发布的 Windows NT 3.1 中，Win32 子系统成为一个特殊的特权“程序”，其他所有的子系统以及整个操作系统都依赖该程序。
在 Windows NT 4.0 之前，Win32 子系统包含 5 个模块，存在于不同 DLL 文件中：
窗口管理器：处理输入以及屏幕 I/O； 图形设备接口(GDI)：图形输出设备的绘画库； 图形设备驱动(GDD)：硬件相关的图形驱动； 控制台：提供文字窗口支持； 操作系统功能：支持子系统中的所有组件。 将图形功能放在单独的 Win32 服务器进程中会造成很大的内存开销以及大量的线程/进程上下文转换操作，极为影响系统性能。而 Windows NT 是一个基于窗口的操作系统，会有大量的图形和窗口操作，因此自 Windows NT 4.</description>
    </item>
    
    <item>
      <title>X64 分页机制</title>
      <link>https://www.zoemurmure.top/posts/x64_paging/</link>
      <pubDate>Tue, 10 Jan 2023 15:09:38 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/x64_paging/</guid>
      <description>前言 在学习 HEVD 的过程中发现有很多知识不了解，这篇文章因此出现，文章内容翻译自参考资料^[1]^，出于学习目的考虑，内容和结构有所调整。
基本定义 首先明确分页(Paging)出现的原因，是为了实现虚拟地址，更方便的做虚拟地址和物理地址的转换。 理论上说，64 位机器可以拥有 2^64^ 字节的内存，但是出于地址转换的效率考虑，并不是所有的 64 位都是可用的。在实际应用时，48~63 位的数值与 47 位保持相同，因为 64 位机器中存在两端有效地址：
0 ~ 0x7FFF FFFFFFFF 0x8000 00000000 ~ 0xFFFFFFFF FFFFFFFF 之所以采用这样的机制，是为了与 32 位机器保持一致，同时便于地址的转换。因为在 32 位机器中，地址空间被平分为两部分，高地址部分用于存储系统代码和数据，这样可以很好的区分应用程序代码和系统代码。由于 48~63 位与 47 位保持一致，因此在做地址转换时不需要考虑这部分数值，而且如果之后 CPU 的能力增强，就可以很方便的使用更多位数，也不需要改变目前的设置。
如果一个虚拟地址的 47~63 位是全 1 或全 0 的，我们就说这个地址是规范(canonical)地址。因此 x64 代码中的所有地址都应该是规范地址，使用非规范地址会导致页错误异常。
地址转换 流程 CPU 使用一系列保存在内存中的表对地址进行转换，整个流程如下：
CR3 寄存器中存储了第一级表的物理地址，该表叫做 Page Map Level 4 (PML4)，大小为 4KB，包含了大小为 8 字节的条目PML4E，下面介绍的其他表具有相同的大小及结构； 虚拟地址的 39 ~ 47 位用于索引 PML4，定位到一个 PML4E； PML4E 中保存了下一级表的物理地址，该表叫做 Page Directory Pointer Table (PDPT)； 虚拟地址的 30 ~ 38 位用于索引 PDPT，定位到一个 PDPTE； PDPTE 中保存了下一级表的物理地址，该表叫做 Page Directory (PD)； 虚拟地址的 21 ~ 29 位用于索引 PD，定位到一个 PDE； PDE 中保存了下一级表的物理地址，该表叫做 Page Table (PT)； 虚拟地址的 12 ~ 20 位用于索引 PT，定位到一个 PTE； PTE 中保存了用于计算最终物理地址的基地址； 虚拟地址的 0 ~ 11 位是偏移量，和上一步的基地址相加得到最终的物理地址。 一些概念 接下来使用分页结构(paging structur, PS)表示上面的各类表，使用 PxE 表示各类表中的条目。</description>
    </item>
    
    <item>
      <title>[HEVD exploit 系列] StackOverflowGS</title>
      <link>https://www.zoemurmure.top/posts/hevd_stackoberflowgs/</link>
      <pubDate>Tue, 10 Jan 2023 11:18:29 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/hevd_stackoberflowgs/</guid>
      <description>0. 前言 HackSys Extreme Vulnerable Driver (HEVD) 是出于学习内核的漏洞利用技巧而开发的具有多个漏洞的 Windows 驱动程序。本文介绍了 Windows 10 64 位环境下如何绕过带有 /GS 保护措施的栈溢出漏洞，涉及 SMEP 和 /GS 两个保护措施。文章中仅贴出部分代码，完整代码见：https://github.com/zoemurmure/HEVD-Exploit
1. 目标函数 TriggerBufferOverflowStackGS
__int64 __fastcall TriggerBufferOverflowStackGS(void *src, unsigned __int64 Size) { char dst[512]; // [rsp+20h] [rbp-238h] BYREF memset(dst, 0, sizeof(dst)); ProbeForRead(src, 0x200ui64, 1u); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] UserBuffer: 0x%p\n&amp;#34;, src); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] UserBuffer Size: 0x%X\n&amp;#34;, Size); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] KernelBuffer: 0x%p\n&amp;#34;, dst); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] KernelBuffer Size: 0x%X\n&amp;#34;, 512i64); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] Triggering Buffer Overflow in Stack (GS)\n&amp;#34;); memmove(dst, src, Size); return 0i64; } 2.</description>
    </item>
    
    <item>
      <title>[HEVD exploit 系列] StackOverflow</title>
      <link>https://www.zoemurmure.top/posts/hevd_stackoverflow/</link>
      <pubDate>Tue, 10 Jan 2023 11:18:24 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/hevd_stackoverflow/</guid>
      <description>目标函数 TriggerBufferOverflowStack
__int64 __fastcall TriggerBufferOverflowStack(void *Src, unsigned __int64 Size) { char Dst[2048]; // [rsp+20h] [rbp-818h] BYREF memset(Dst, 0, sizeof(Dst)); ProbeForRead(Src, 0x800ui64, 1u); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] UserBuffer: 0x%p\n&amp;#34;, Src); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] UserBuffer Size: 0x%X\n&amp;#34;, Size); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] KernelBuffer: 0x%p\n&amp;#34;, Dst); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] KernelBuffer Size: 0x%X\n&amp;#34;, 0x800i64); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] Triggering Buffer Overflow in Stack\n&amp;#34;); memmove(Dst, Src, Size); return 0i64; } 保护措施：SMEP^[3]^ 定义 SMEP，即 Supervisor Mode Execution Protection，主管模式执行保护。该措施可以保证应用程序在更高特权级别运行时，不会在不受信任的程序内存中执行代码。
该机制通过控制寄存器^[2]^ CR4 的第 20 位实现，1 表示启用。</description>
    </item>
    
    <item>
      <title>历史文章合集</title>
      <link>https://www.zoemurmure.top/history/</link>
      <pubDate>Wed, 21 Jul 2021 21:44:54 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/history/</guid>
      <description>以前写的一些文章，按照时间倒序排列
如何阅读只包含特殊符号的powershell脚本
Golang版本简易fuzzer及debugger实践
Chrom V8分析入门——Google CTF2018 justintime分析
详细分析CVE-2021-40444远程命令执行漏洞
全网最详细CVE-2014-0502 Adobe Flash Player双重释放漏洞分析
再探格式化字符串漏洞：CVE-2012-3569 ovftool.exe
殊途同归的CVE-2012-0774 TrueType字体整数溢出漏洞分析
CVE-2012-0003 winmm.dll MIDI文件堆溢出漏洞分析及利用
CVE-2011-0104 Excel TOOLBARDEF Record栈溢出漏洞分析与利用
跳转到shellcode的方法——Exploit编写系列教程学习笔记2
CVE-2011-2110 AdobeFlashPlayer数组越界访问漏洞分析
超级长的IE调试总结：CVE-2013-1347 IE CGenericElement UAF漏洞分析
如何利用栈溢出漏洞1——Exploit编写系列教程学习笔记
极为详细的一次双重释放漏洞调试分析经历
格式化字符串漏洞利用方法及CVE-2012-0809漏洞分析
CVE-2011-0027 Microsoft Data Access Components整数溢出漏洞分析
我竟然发现了书中的一个bug：CVE-2010-2553 堆溢出漏洞分析
新的漏洞分析体验：CVE-2010-3333 RTF栈缓冲区溢出漏洞
CVE-2010-2883分析_更新：如何自己构造poc文件
一次上当受骗的样本分析经验
ms08-067及msf exploit调试与分析
0day安全学习笔记：MS06-040漏洞分析
python exe文件解包方法总结
双向进攻：分析tcpdump DOS漏洞成因
一个KimsukyAPT样本分析
可以修改indexing string的base64编码实现
CVE-2020-8816: Pi-hole中的远程代码执行漏洞分析及复现</description>
    </item>
    
  </channel>
</rss>
