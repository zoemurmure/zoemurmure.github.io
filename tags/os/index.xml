<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>os on Logic Security 逻辑门</title>
    <link>https://www.zoemurmure.top/tags/os/</link>
    <description>Recent content in os on Logic Security 逻辑门</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 10 Jan 2023 17:07:41 +0800</lastBuildDate><atom:link href="https://www.zoemurmure.top/tags/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CSRSS 基础知识</title>
      <link>https://www.zoemurmure.top/posts/csrss_base/</link>
      <pubDate>Tue, 10 Jan 2023 17:07:41 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/csrss_base/</guid>
      <description>0. 前言 这是一篇不完整的 csrss 介绍，因为前段时间在看 csrss 相关的漏送，所以对相关的知识做了一下整理，因此你无法只通过这篇文章完全了解 csrss，但是如果这篇文章能够解答你在学习 csrss 时的一些疑惑，那么它的目的就达成了。
1. 历史背景 1.1 微内核(microkernel)的概念 微内核指一个现代化、模块化操作系统中最核心的部分，微内核操作系统有两个原则：
模块化、封装性和数据隐藏。即操作系统中有且仅有一部分对一个特定功能具有系统范围内的责任，操作系统中的其他部分，包括应用程序只能通过定义好的接口对使用该功能； 操作系统中的大部分功能在用户/应用程序模式下执行，只有微内核本身及硬件相关的小部分代码在内核态下执行。 遵循以上两个原则的操作系统叫做纯微内核系统，仅遵循第一个原则但不遵循第二个原则的操作系统叫做修改后的微内核(modified microkernel)或者宏内核(macrokernel)操作系统。商业性质的操作系统一般不会基于纯微内核进行设计，因为这样的架构计算成本太大。
Windows NT 就是修改后的微内核系统，具有非常好的模块化和封装性，另一方面，从最初版本开始，Windows NT 就在内核态实现了高性能操作系统子系统，这些子系统可以在内核模式下与硬件交互以及相互交互，而不会影响处理器模式以及进程/线程转换的性能。作为内核态子系统实现的有内存管理器、集成缓存管理器、文件系统、对象/安全管理器、网络协议、网络服务器以及所有的线程/进程管理。
然而在 Windows NT 4.0 之前，有一个领域一直采取纯微内核模式，也就是窗口管理器以及图形化子系统，它们用于实现 Win32 API 中的 GUI 部分。在 Windows NT 3.51 及之前的版本中，窗口管理器和 GDI 作为一个单独的用户态进程 Client-Server Subsystem(csrss.exe) 实现。
1.2 Win32 子系统 在 Windows NT 的最初设计阶段，Win32 被设计为等同于 OS/2、POSIX 以及其他计划中的操作系统环境。每个这样的子系统都作为一个独立的环境运行。但是这种设计会导致存在大量重复的系统功能，影响系统规模以及性能。为了避免重复，以及响应市场趋势，最终发布的 Windows NT 3.1 中，Win32 子系统成为一个特殊的特权“程序”，其他所有的子系统以及整个操作系统都依赖该程序。
在 Windows NT 4.0 之前，Win32 子系统包含 5 个模块，存在于不同 DLL 文件中：
窗口管理器：处理输入以及屏幕 I/O； 图形设备接口(GDI)：图形输出设备的绘画库； 图形设备驱动(GDD)：硬件相关的图形驱动； 控制台：提供文字窗口支持； 操作系统功能：支持子系统中的所有组件。 将图形功能放在单独的 Win32 服务器进程中会造成很大的内存开销以及大量的线程/进程上下文转换操作，极为影响系统性能。而 Windows NT 是一个基于窗口的操作系统，会有大量的图形和窗口操作，因此自 Windows NT 4.</description>
    </item>
    
    <item>
      <title>X64 分页机制</title>
      <link>https://www.zoemurmure.top/posts/x64_paging/</link>
      <pubDate>Tue, 10 Jan 2023 15:09:38 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/x64_paging/</guid>
      <description>前言 在学习 HEVD 的过程中发现有很多知识不了解，这篇文章因此出现，文章内容翻译自参考资料^[1]^，出于学习目的考虑，内容和结构有所调整。
基本定义 首先明确分页(Paging)出现的原因，是为了实现虚拟地址，更方便的做虚拟地址和物理地址的转换。 理论上说，64 位机器可以拥有 2^64^ 字节的内存，但是出于地址转换的效率考虑，并不是所有的 64 位都是可用的。在实际应用时，48~63 位的数值与 47 位保持相同，因为 64 位机器中存在两端有效地址：
0 ~ 0x7FFF FFFFFFFF 0x8000 00000000 ~ 0xFFFFFFFF FFFFFFFF 之所以采用这样的机制，是为了与 32 位机器保持一致，同时便于地址的转换。因为在 32 位机器中，地址空间被平分为两部分，高地址部分用于存储系统代码和数据，这样可以很好的区分应用程序代码和系统代码。由于 48~63 位与 47 位保持一致，因此在做地址转换时不需要考虑这部分数值，而且如果之后 CPU 的能力增强，就可以很方便的使用更多位数，也不需要改变目前的设置。
如果一个虚拟地址的 47~63 位是全 1 或全 0 的，我们就说这个地址是规范(canonical)地址。因此 x64 代码中的所有地址都应该是规范地址，使用非规范地址会导致页错误异常。
地址转换 流程 CPU 使用一系列保存在内存中的表对地址进行转换，整个流程如下：
CR3 寄存器中存储了第一级表的物理地址，该表叫做 Page Map Level 4 (PML4)，大小为 4KB，包含了大小为 8 字节的条目PML4E，下面介绍的其他表具有相同的大小及结构； 虚拟地址的 39 ~ 47 位用于索引 PML4，定位到一个 PML4E； PML4E 中保存了下一级表的物理地址，该表叫做 Page Directory Pointer Table (PDPT)； 虚拟地址的 30 ~ 38 位用于索引 PDPT，定位到一个 PDPTE； PDPTE 中保存了下一级表的物理地址，该表叫做 Page Directory (PD)； 虚拟地址的 21 ~ 29 位用于索引 PD，定位到一个 PDE； PDE 中保存了下一级表的物理地址，该表叫做 Page Table (PT)； 虚拟地址的 12 ~ 20 位用于索引 PT，定位到一个 PTE； PTE 中保存了用于计算最终物理地址的基地址； 虚拟地址的 0 ~ 11 位是偏移量，和上一步的基地址相加得到最终的物理地址。 一些概念 接下来使用分页结构(paging structur, PS)表示上面的各类表，使用 PxE 表示各类表中的条目。</description>
    </item>
    
  </channel>
</rss>
