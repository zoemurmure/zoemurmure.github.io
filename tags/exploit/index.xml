<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>exploit on Logic Security 逻辑门</title>
    <link>https://www.zoemurmure.top/tags/exploit/</link>
    <description>Recent content in exploit on Logic Security 逻辑门</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 21 Apr 2023 09:52:44 +0800</lastBuildDate><atom:link href="https://www.zoemurmure.top/tags/exploit/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CVE-2023-21768 AFD for WinSock 提权漏洞利用思路探索</title>
      <link>https://www.zoemurmure.top/posts/cve_2023_21768/</link>
      <pubDate>Fri, 21 Apr 2023 09:52:44 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/cve_2023_21768/</guid>
      <description>1. 前言 这篇文章分析了 CVE-2023-21768 漏洞，该漏洞存在于 Windows 操作系统的 AFD 驱动程序中。文章中原文指代参考链接[1]的文章，通过对该篇文章的学习，我复现并重新编写了 exploit 代码，同时根据他人在编写漏洞利用程序时的步骤，分析自己的不足之处。
文章中涉及漏洞基础分析、漏洞触发尝试(poc)、漏洞利用实现三个主要部分，同时对漏洞利用时涉及到的 I/O Ring 知识点做了简单介绍。
2. 补丁对比 通过补丁对比确定漏洞修复函数为 AfdNotifyRemoveIoCompletion，修复点增加了对于某个结构字段是否可写的检查，然后才执行赋值操作：
也就是说，漏洞未修复前，该字段可能被攻击者控制，从而写入到其他位置。
原文首先进行的是补丁对比，这是进行 Windows 漏洞分析的基本操作，如果没有其他信息，也是我在漏洞分析时会首先进行的步骤。补丁对比通常可以确定修复函数的位置，同时获取关于漏洞的一些信息。
在对修复前后的 afd.sys 文件进行对比后，发现只有一个函数进行了细微的改动，这种情况是比较幸运的，因为通常会发现存在多个函数被修改，而且改动幅度也可能很大，如果没有其他信息，很难确定漏洞究竟发生在哪个位置。
3. 交叉引用检查 根据上一小节的结论，可被攻击者控制的字段 a3 + 24 是函数 AfdNotifyRemoveIoCompletion 的第三个参数中的字段，也就是说第三个参数是一个未知结构体。
接下来检查 AfdNotifyRemoveIoCompletion 的交叉引用，看一下这个参数的来源：
.rdata:00000001C004D658 dq offset AfdNotifySock .rdata:00000001C004D660 AfdIrpCallDispatch dq offset AfdBind → AfdNotifySock(__int64 a1, __int64 a2, KPROCESSOR_MODE a3, ULONG64 a4, int a5, __int64 a6, int a7) → AfdNotifyRemoveIoCompletion(a3, v1, a4) 也就是说，AfdNotifyRemoveIoCompletion 的第三个参数是 AfdNotifySock 的第四个参数，而 AfdNotifySock 位于 AfdIrpCallDispatch 的上面。</description>
    </item>
    
    <item>
      <title>[HEVD exploit 系列] StackOverflowGS</title>
      <link>https://www.zoemurmure.top/posts/hevd_stackoberflowgs/</link>
      <pubDate>Tue, 10 Jan 2023 11:18:29 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/hevd_stackoberflowgs/</guid>
      <description>0. 前言 HackSys Extreme Vulnerable Driver (HEVD) 是出于学习内核的漏洞利用技巧而开发的具有多个漏洞的 Windows 驱动程序。本文介绍了 Windows 10 64 位环境下如何绕过带有 /GS 保护措施的栈溢出漏洞，涉及 SMEP 和 /GS 两个保护措施。文章中仅贴出部分代码，完整代码见：https://github.com/zoemurmure/HEVD-Exploit
1. 目标函数 TriggerBufferOverflowStackGS
__int64 __fastcall TriggerBufferOverflowStackGS(void *src, unsigned __int64 Size) { char dst[512]; // [rsp+20h] [rbp-238h] BYREF memset(dst, 0, sizeof(dst)); ProbeForRead(src, 0x200ui64, 1u); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] UserBuffer: 0x%p\n&amp;#34;, src); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] UserBuffer Size: 0x%X\n&amp;#34;, Size); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] KernelBuffer: 0x%p\n&amp;#34;, dst); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] KernelBuffer Size: 0x%X\n&amp;#34;, 512i64); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] Triggering Buffer Overflow in Stack (GS)\n&amp;#34;); memmove(dst, src, Size); return 0i64; } 2.</description>
    </item>
    
    <item>
      <title>[HEVD exploit 系列] StackOverflow</title>
      <link>https://www.zoemurmure.top/posts/hevd_stackoverflow/</link>
      <pubDate>Tue, 10 Jan 2023 11:18:24 +0800</pubDate>
      
      <guid>https://www.zoemurmure.top/posts/hevd_stackoverflow/</guid>
      <description>目标函数 TriggerBufferOverflowStack
__int64 __fastcall TriggerBufferOverflowStack(void *Src, unsigned __int64 Size) { char Dst[2048]; // [rsp+20h] [rbp-818h] BYREF memset(Dst, 0, sizeof(Dst)); ProbeForRead(Src, 0x800ui64, 1u); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] UserBuffer: 0x%p\n&amp;#34;, Src); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] UserBuffer Size: 0x%X\n&amp;#34;, Size); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] KernelBuffer: 0x%p\n&amp;#34;, Dst); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] KernelBuffer Size: 0x%X\n&amp;#34;, 0x800i64); DbgPrintEx(0x4Du, 3u, &amp;#34;[+] Triggering Buffer Overflow in Stack\n&amp;#34;); memmove(Dst, Src, Size); return 0i64; } 保护措施：SMEP^[3]^ 定义 SMEP，即 Supervisor Mode Execution Protection，主管模式执行保护。该措施可以保证应用程序在更高特权级别运行时，不会在不受信任的程序内存中执行代码。
该机制通过控制寄存器^[2]^ CR4 的第 20 位实现，1 表示启用。</description>
    </item>
    
  </channel>
</rss>
