<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>[CVE-2023-21752] Windows Backup Service 本地提权漏洞分析（一） - Logic Security 逻辑门</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[CVE-2023-21752] Windows Backup Service 本地提权漏洞分析（一）" />
<meta property="og:description" content="0. 前言 CVE-2023-21752 是 2023 年开年微软第一个有 exploit 的漏洞，原本以为有利用代码会很好分析，结果时间竟然都花在了漏洞点定位上，由此可见我之前在漏洞分析流程上偷了多少懒，以此记录并警示。
1. 漏洞简介 根据官方信息，该漏洞是 Windows Backup Service 中的权限提升漏洞，经过身份认证的攻击者可利用此漏洞提升至 SYSTEM 权限。成功利用此漏洞需要攻击者赢得竞争条件。
EXP 代码位于 Github，提供了两个版本，版本 1 可以实现任意文件删除，可稳定复现；版本 2 尝试利用任意删除实现本地提权，但是复现不稳定。
2. 漏洞点定位的曲折之路 这部分内容是一些失败的过程记录，以及我自己的碎碎念，防止自己之后犯同样的错误，只对漏洞分析感兴趣的可以略过 2.1 和 2.3 小节。
2.1 失败的过程 首先尝试复现，提权版本的利用程序在虚拟机上没有复现成功，任意文件删除版本的利用程序由于我没有使用完整路径，也没有复现成功（但是此时我还不知道原因）。
之后我尝试进行补丁对比，但是想要进行补丁对比首先要确定漏洞位于哪个文件中，根据漏洞利用程序的文件命名 SDRsvcEop，找到了文件 sdrsvc.dll，但是补丁对比后并没有发现差异。
这期间我还搜索了关于这个漏洞的信息，但是除了漏洞通告和 GitHub 的 exp 代码外，没有找到其他内容。这里吐槽一下某数字站的漏洞通告，竟然说这个漏洞是 Windows Server Backup (WSB) 上的……
这个时候我已经开始对漏洞利用代码进行分析了，一方面通过微软的文档，了解代码中一些函数和参数的使用，一方面开始在 Windbg 上进行调试，并由此找到了 rpcrt4.dll、combase.dll 这些和漏洞无关的文件。
在调试过程中，我花费了很多时间在 DeviceIoControl 这个函数上，因为之前看的很多漏洞最终定位的文件都是 sys 驱动文件，因此虽然我在心里仍旧为 dll 文件留了一些位置，但是在方法选择上，我仍旧趋向去寻找某个 sys 文件。所以我想要在利用程序执行到 DeviceIoControl 的时候，在用户态转内核态的入口位置设置一个断点，然后监控系统究竟执行到了哪里。当然，这个方法失败了，并且搞得我心烦意乱。
我在这个时候才想起来要把利用程序参数的相对路径改成绝对路径，并且成功复现了任意文件删除。虽然但是，这之后我又走了弯路……
之前学习病毒分析的时候，有一个算是标准的流程，就是要先执行病毒，看一下它的动态特征，以此方便后面的动态分析。之前看的很多漏洞分析文章，也都是要执行一下 poc 或者 exp，进行进程监控，但是我完全忘记了，或者说我虽然想到了这个方法，但是并没有十分重视。
我在继续分析漏洞利用代码，在此期间看了一些关于 DCOM 的资料，确定 sdrsvc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.zoemurmure.top/posts/cve_2023_21752_1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-17T19:06:30+08:00" />
<meta property="article:modified_time" content="2023-01-17T19:06:30+08:00" />

		<meta itemprop="name" content="[CVE-2023-21752] Windows Backup Service 本地提权漏洞分析（一）">
<meta itemprop="description" content="0. 前言 CVE-2023-21752 是 2023 年开年微软第一个有 exploit 的漏洞，原本以为有利用代码会很好分析，结果时间竟然都花在了漏洞点定位上，由此可见我之前在漏洞分析流程上偷了多少懒，以此记录并警示。
1. 漏洞简介 根据官方信息，该漏洞是 Windows Backup Service 中的权限提升漏洞，经过身份认证的攻击者可利用此漏洞提升至 SYSTEM 权限。成功利用此漏洞需要攻击者赢得竞争条件。
EXP 代码位于 Github，提供了两个版本，版本 1 可以实现任意文件删除，可稳定复现；版本 2 尝试利用任意删除实现本地提权，但是复现不稳定。
2. 漏洞点定位的曲折之路 这部分内容是一些失败的过程记录，以及我自己的碎碎念，防止自己之后犯同样的错误，只对漏洞分析感兴趣的可以略过 2.1 和 2.3 小节。
2.1 失败的过程 首先尝试复现，提权版本的利用程序在虚拟机上没有复现成功，任意文件删除版本的利用程序由于我没有使用完整路径，也没有复现成功（但是此时我还不知道原因）。
之后我尝试进行补丁对比，但是想要进行补丁对比首先要确定漏洞位于哪个文件中，根据漏洞利用程序的文件命名 SDRsvcEop，找到了文件 sdrsvc.dll，但是补丁对比后并没有发现差异。
这期间我还搜索了关于这个漏洞的信息，但是除了漏洞通告和 GitHub 的 exp 代码外，没有找到其他内容。这里吐槽一下某数字站的漏洞通告，竟然说这个漏洞是 Windows Server Backup (WSB) 上的……
这个时候我已经开始对漏洞利用代码进行分析了，一方面通过微软的文档，了解代码中一些函数和参数的使用，一方面开始在 Windbg 上进行调试，并由此找到了 rpcrt4.dll、combase.dll 这些和漏洞无关的文件。
在调试过程中，我花费了很多时间在 DeviceIoControl 这个函数上，因为之前看的很多漏洞最终定位的文件都是 sys 驱动文件，因此虽然我在心里仍旧为 dll 文件留了一些位置，但是在方法选择上，我仍旧趋向去寻找某个 sys 文件。所以我想要在利用程序执行到 DeviceIoControl 的时候，在用户态转内核态的入口位置设置一个断点，然后监控系统究竟执行到了哪里。当然，这个方法失败了，并且搞得我心烦意乱。
我在这个时候才想起来要把利用程序参数的相对路径改成绝对路径，并且成功复现了任意文件删除。虽然但是，这之后我又走了弯路……
之前学习病毒分析的时候，有一个算是标准的流程，就是要先执行病毒，看一下它的动态特征，以此方便后面的动态分析。之前看的很多漏洞分析文章，也都是要执行一下 poc 或者 exp，进行进程监控，但是我完全忘记了，或者说我虽然想到了这个方法，但是并没有十分重视。
我在继续分析漏洞利用代码，在此期间看了一些关于 DCOM 的资料，确定 sdrsvc."><meta itemprop="datePublished" content="2023-01-17T19:06:30+08:00" />
<meta itemprop="dateModified" content="2023-01-17T19:06:30+08:00" />
<meta itemprop="wordCount" content="522">
<meta itemprop="keywords" content="cve,binary," />
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
<script async src="https://www.googletagmanager.com/gtag/js?id=G-CPJWE5ZVG9"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-CPJWE5ZVG9', { 'anonymize_ip': false });
}
</script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="Logic Security 逻辑门" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/img/blog_img.png">
				</div><div class="logo__item logo__text">
					<div class="logo__title">Logic Security 逻辑门</div>
					
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">Home</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/history/">
				
				<span class="menu__text">历史文章</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[CVE-2023-21752] Windows Backup Service 本地提权漏洞分析（一）</h1>
			<div class="post__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">zoemurmure</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2023-01-17T19:06:30&#43;08:00">2023-01-17</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="category">漏洞分析</a>
	</span>
</div></div>
		</header>
		
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#0-前言">0. 前言</a></li>
    <li><a href="#1-漏洞简介">1. 漏洞简介</a></li>
    <li><a href="#2-漏洞点定位的曲折之路">2. 漏洞点定位的曲折之路</a>
      <ul>
        <li><a href="#21-失败的过程">2.1 失败的过程</a></li>
        <li><a href="#22-转入正轨">2.2 转入正轨</a></li>
        <li><a href="#23-反思">2.3 反思</a></li>
      </ul>
    </li>
    <li><a href="#3-漏洞原理">3. 漏洞原理</a>
      <ul>
        <li><a href="#31-补丁对比">3.1 补丁对比</a></li>
        <li><a href="#32-漏洞原理分析">3.2 漏洞原理分析</a></li>
      </ul>
    </li>
    <li><a href="#4-文件删除漏洞利用代码流程总结">4. 文件删除漏洞利用代码流程总结</a></li>
    <li><a href="#5-小节">5. 小节</a></li>
    <li><a href="#6-参考资料">6. 参考资料</a></li>
  </ul>
</nav>
	</div>
</div><div class="content post__content clearfix">
			<h2 id="0-前言">0. 前言</h2>
<p>CVE-2023-21752 是 2023 年开年微软第一个有 exploit 的漏洞，原本以为有利用代码会很好分析，结果时间竟然都花在了漏洞点定位上，由此可见我之前在漏洞分析流程上偷了多少懒，以此记录并警示。</p>
<h2 id="1-漏洞简介">1. 漏洞简介</h2>
<p>根据官方信息，该漏洞是 Windows Backup Service 中的权限提升漏洞，经过身份认证的攻击者可利用此漏洞提升至 SYSTEM 权限。成功利用此漏洞需要攻击者赢得竞争条件。</p>
<p>EXP 代码位于 <a href="https://github.com/Wh04m1001/CVE-2023-21752">Github</a>，提供了两个版本，版本 1 可以实现任意文件删除，可稳定复现；版本 2 尝试利用任意删除实现本地提权，但是复现不稳定。</p>
<h2 id="2-漏洞点定位的曲折之路">2. 漏洞点定位的曲折之路</h2>
<p>这部分内容是一些失败的过程记录，以及我自己的碎碎念，防止自己之后犯同样的错误，只对漏洞分析感兴趣的可以略过 2.1 和 2.3 小节。</p>
<h3 id="21-失败的过程">2.1 失败的过程</h3>
<p>首先尝试复现，提权版本的利用程序在虚拟机上没有复现成功，任意文件删除版本的利用程序由于我没有使用完整路径，也没有复现成功（但是此时我还不知道原因）。</p>
<p>之后我尝试进行补丁对比，但是想要进行补丁对比首先要确定漏洞位于哪个文件中，根据漏洞利用程序的文件命名 <code>SDRsvcEop</code>，找到了文件 sdrsvc.dll，但是补丁对比后并没有发现差异。</p>
<blockquote>
<p>这期间我还搜索了关于这个漏洞的信息，但是除了漏洞通告和 GitHub 的 exp 代码外，没有找到其他内容。这里吐槽一下某数字站的漏洞通告，竟然说这个漏洞是 Windows Server Backup (WSB) 上的……</p>
</blockquote>
<p>这个时候我已经开始对漏洞利用代码进行分析了，一方面通过微软的文档，了解代码中一些函数和参数的使用，一方面开始在 Windbg 上进行调试，并由此找到了 rpcrt4.dll、combase.dll 这些和漏洞无关的文件。</p>
<p>在调试过程中，我花费了很多时间在 <code>DeviceIoControl</code> 这个函数上，因为之前看的很多漏洞最终定位的文件都是 sys 驱动文件，因此虽然我在心里仍旧为 dll 文件留了一些位置，但是在方法选择上，我仍旧趋向去寻找某个 sys 文件。所以我想要在利用程序执行到 <code>DeviceIoControl</code> 的时候，在用户态转内核态的入口位置设置一个断点，然后监控系统究竟执行到了哪里。当然，这个方法失败了，并且搞得我心烦意乱。</p>
<p>我在这个时候才想起来要把利用程序参数的相对路径改成绝对路径，并且成功复现了任意文件删除。虽然但是，这之后我又走了弯路……</p>
<blockquote>
<p>之前学习病毒分析的时候，有一个算是标准的流程，就是要先执行病毒，看一下它的动态特征，以此方便后面的动态分析。之前看的很多漏洞分析文章，也都是要执行一下 poc 或者 exp，进行进程监控，但是我完全忘记了，或者说我虽然想到了这个方法，但是并没有十分重视。</p>
</blockquote>
<p>我在继续分析漏洞利用代码，在此期间看了一些关于 DCOM 的资料，确定 sdrsvc.dll 是依赖 rpcss.dll 文件功能的（明明可以通过 process hacker 直接确定的……），通过补丁对比发现函数 <code>CServerSet::RemoveObject</code> 被修改，我尝试在 Windbg 中在这个函数设置断点，但是利用程序没有执行到这里，所以漏洞点不在这个文件。</p>
<blockquote>
<p>其中这个时候我的潜意识已经告诉我我的路走错了，因为微软的漏洞说明上明明白白的写着 Windows backup service，所以漏洞文件肯定是和这个功能直接相关的文件，要不然它就直接写 RPC 漏洞了。</p>
</blockquote>
<h3 id="22-转入正轨">2.2 转入正轨</h3>
<p>此时我仍旧没有使用 procmon 对利用程序进行监控，我选择在安装补丁前后的系统上执行利用程序，并检查输出（输出内容做了一些修改），得到以下结果（因为只是测试功能，并没有选择对高权限文件进行删除）：</p>
<p>补丁修复前</p>
<pre tabindex="0"><code>PS C:\Users\exp\Desktop&gt; C:\Users\exp\Desktop\SDRsvcEop.exe C:\Users\exp\Desktop\test.txt
[wmain] Directory: C:\users\exp\appdata\local\temp\23980418-9164-497e-8ce7-930949d1af55
[Trigger] Path: \\127.0.0.1\c$\Users\exp\AppData\Local\Temp\23980418-9164-497e-8ce7-930949d1af55
[FindFile] Catch FILE_ACTION_ADDED of C:\users\exp\appdata\local\temp\23980418-9164-497e-8ce7-930949d1af55\SDT2C35.tmp
[FindFile] Start to CreateLock...
[cb] Oplock!
[CreateJunction] Junction \\?\C:\Users\exp\AppData\Local\Temp\23980418-9164-497e-8ce7-930949d1af55 -&gt; \RPC Control created!
[DosDeviceSymLink] Symlink Global\GLOBALROOT\RPC Control\SDT2C35.tmp -&gt; \??\C:\Users\exp\Desktop\test.txt created!
[Trigger] Finish sdc-&gt;proc7
[wmain] Exploit successful!
[DeleteJunction] Junction \\?\C:\Users\exp\AppData\Local\Temp\23980418-9164-497e-8ce7-930949d1af55 deleted!
[DelDosDeviceSymLink] Symlink Global\GLOBALROOT\RPC Control\SDT2C35.tmp -&gt; \??\C:\Users\exp\Desktop\test.txt deleted!
</code></pre><p>补丁修复后</p>
<pre tabindex="0"><code>PS C:\Users\exp\Desktop&gt; C:\Users\exp\Desktop\SDRsvcEop.exe C:\Users\exp\Desktop\test.txt
[wmain] Directory: C:\users\exp\appdata\local\temp\183c772e-f444-4aec-a489-7d9f734ee719
[Trigger] Path: \\127.0.0.1\c$\Users\exp\AppData\Local\Temp\183c772e-f444-4aec-a489-7d9f734ee719
[FindFile] Catch FILE_ACTION_ADDED of C:\users\exp\appdata\local\temp\183c772e-f444-4aec-a489-7d9f734ee719\SDT1F8A.tmp
[Trigger] Finish sdc-&gt;proc7
_
</code></pre><p>由此可知修复后利用程序无法再获取一个 tmp 文件的句柄，我猜测应该是补丁修复之前，漏洞文件创建了这个 tmp 文件，并且创建的权限有问题（这个猜测不一定准确），但是这个猜测目前没什么用，还是没办法定位漏洞文件。</p>
<p>然后，几乎走投无路的我终于想起来要用 procmon 了，谢天谢地。</p>
<p>根据上面利用程序输出结果的对比，确定漏洞修复的位置和创建的 tmp 文件有关，因此格外注意 procmon 中该文件的创建操作：</p>
<p><img src="/img/2023-01-17-11-02-32.png" alt=""></p>
<p>并在 Stack 选项卡中，定位到 sdrsvc.dll 调用的功能位于 sdengin2.dll 中：</p>
<p><img src="/img/2023-01-17-11-05-46.png" alt=""></p>
<p>根据 <code>SdCheck + 0x490c2</code>，在 IDA 中定位到函数 <code>CSdCommonImpl::QueryStorageDevice</code>，该地址为这个函数调用 <code>QueryStorageDevice</code> 的位置。</p>
<p>经过补丁对比，发现了函数 <code>IsWritable</code>，这个函数进行了修改，并且被 <code>QueryStorageDevice</code> 所调用。</p>
<h3 id="23-反思">2.3 反思</h3>
<p>这次漏洞分析遇到了几个障碍：</p>
<ol>
<li>无法通过漏洞名称直接确认漏洞文件，导致无法使用常用的补丁对比的分析方法；</li>
<li>exp 一开始未成功复现，这种情况对我来说很常见，但是由于不清楚原因，我以为是对备份服务的功能以及 exp 代码不熟悉导致；</li>
<li>由于不熟悉利用代码：
<ol>
<li>花费很多时间查找相关资料；</li>
<li>需要对辅助功能代码和直接漏洞利用代码进行区分。</li>
</ol>
</li>
</ol>
<p>除此之外，我之前极少分析带有 exp 且 exp 可以正常复现的漏洞，习惯从静态分析入手，再使用 windbg 动态辅助分析。一般遇到可以使用的 poc，我也是直接触发崩溃，然后使用 windbg 从崩溃开始进行调试分析，从没有使用过 procmon 进行动态监控，并且这样的方法也都成功对漏洞进行了分析，因此轻视了 procmon 动态监控方法的有效性。</p>
<p>不过 procmon 也不是万能的，目前看来，这个方法在漏洞点定位上十分有效，但是如果通过其他信息已经能够对漏洞点进行定位，那么 procmon 提供的帮助就不那么显著了，而且通过其他方法也能够完成漏洞分析。</p>
<h2 id="3-漏洞原理">3. 漏洞原理</h2>
<h3 id="31-补丁对比">3.1 补丁对比</h3>
<p>漏洞修复前：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">IsWritable</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int16</span> <span style="color:#f92672">*</span>a1, <span style="color:#66d9ef">int</span> a2, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a3)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  v7 <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( a2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">7</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>GetTempFileNameW(a1, <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;SDT&#34;</span>, <span style="color:#ae81ff">0</span>, TempFileName) )<span style="color:#75715e">// 如果获取 temp 文件名失败，进入 if 语句
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>      rtnValue <span style="color:#f92672">=</span> v17;
</span></span><span style="display:flex;"><span>LABEL_28:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">*</span>a3 <span style="color:#f92672">=</span> v6;
</span></span><span style="display:flex;"><span>toend2:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( v7 <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        CloseHandle(v7);
</span></span><span style="display:flex;"><span>        rtnValue <span style="color:#f92672">=</span> v17;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> end;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    rtnValue <span style="color:#f92672">=</span> SxDeleteFile(TempFileName);      <span style="color:#75715e">// 删除之前可能存在的 tmp 文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    v17 <span style="color:#f92672">=</span> rtnValue;
</span></span><span style="display:flex;"><span>    v8 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x148</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( rtnValue <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> )                        <span style="color:#75715e">// 删除成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>      v18 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x148</span>;
</span></span><span style="display:flex;"><span>LABEL_27:
</span></span><span style="display:flex;"><span>      v6 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> LABEL_28;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>toend:
</span></span><span style="display:flex;"><span>    v19 <span style="color:#f92672">=</span> v8;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> end;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述代码中的 a2 和传入的路径类型有关，由于利用程序传入的是 UNC 路径，因此最终程序执行流程到达此处。</p>
<p>根据 <code>GetTempFileNameW</code> 函数的文档说明，当其第三个参数为数值 0 时，该函数会尝试使用系统时间生成一个唯一数字文件名，如果该文件已存在，数字递增直至文件名唯一，在这种情况下，该函数会创建一个该文件名的空文件并释放其句柄。因此在漏洞修复之前，系统通过 <code>GetTempFileNameW</code> 创建临时文件是否成功的方式检查传入的 unc 路径是否可以写入，如果可以写入，再删除创建的这个临时文件。</p>
<p>漏洞修复后：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">IsWritable</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int16</span> <span style="color:#f92672">*</span>a1, <span style="color:#66d9ef">int</span> a2, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a3)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  v7 <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( a2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">7</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( CheckDevicePathIsWritable(a1) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>LABEL_10:
</span></span><span style="display:flex;"><span>      rtnValue <span style="color:#f92672">=</span> v16;
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">*</span>a3 <span style="color:#f92672">=</span> v6;
</span></span><span style="display:flex;"><span>toend2:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( v7 <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        CloseHandle(v7);
</span></span><span style="display:flex;"><span>        rtnValue <span style="color:#f92672">=</span> v16;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> end;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>LABEL_9:
</span></span><span style="display:flex;"><span>    v6 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> LABEL_10;
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>漏洞修复后，原本 <code>GetTempFileNameW</code> 函数的位置变成了 <code>CheckDevicePathIsWritable</code>，<code>GetTempFileNameW</code> 函数的实现位于 kernelbase.dll 文件中，如果你仔细对比，会发现这两个函数中的大部分代码相同，只有一处差异点需要注意，就是在创建临时文件的时候，两者的代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// GetTempFileNameW
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>v24 <span style="color:#f92672">=</span> CreateFileW(lpTempFileName, GENERIC_READ, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>i64, <span style="color:#ae81ff">1u</span>, <span style="color:#ae81ff">0x80u</span>, <span style="color:#ae81ff">0</span>i64);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CheckDevicePathIsWritable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>v22 <span style="color:#f92672">=</span> CreateFileW(FileName, GENERIC_READ, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>i64, <span style="color:#ae81ff">1u</span>, <span style="color:#ae81ff">0x4000080u</span>, <span style="color:#ae81ff">0</span>i64);
</span></span></code></pre></div><p>可以看到在 <code>CheckDevicePathIsWritable</code> 函数中，<code>CreateFileW</code> 函数的第六个参数 <code>dwFlagsAndAttributes</code> 数值由 <code>0x80</code> 变成了 <code>0x4000080</code>，即从 <code>FILE_ATTRIBUTE_NORMAL</code> 变成了 <code>FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE</code>。</p>
<p>根据文档说明，<code>FILE_FLAG_DELETE_ON_CLOSE</code> 表示文件会在所有句柄关闭时直接删除，并且之后打开该文件的请求必须包含 <code>FILE_SHARE_DELETE</code> 共享模式，否则会失败。</p>
<p>简单来说，修复后的代码将临时文件的创建和删除操作整合成为了一个元操作。</p>
<h3 id="32-漏洞原理分析">3.2 漏洞原理分析</h3>
<p>上面补丁对比的结果可以确定这是一个条件竞争漏洞，由于临时文件的创建操作和删除操作接次发生，并且在两个操作之间没有对文件进行限制，这就导致攻击者可以创建另一线程，在临时文件创建之后，删除之前，获取文件句柄并创建机会锁阻止其他线程操作，同时将文件删除，并设置原文件路径指向其他文件，当机会锁释放后，指向的其他文件就会被删除。</p>
<h2 id="4-文件删除漏洞利用代码流程总结">4. 文件删除漏洞利用代码流程总结</h2>
<ol>
<li>在临时文件夹下，使用 <code>FULL_SHARING</code> 模式创建目录 dir ，作为上述临时文件的保存位置;</li>
<li>创建线程 FindFile，监控 dir 目录下的文件创建操作：
<ol>
<li>获取创建文件句柄并创建机会锁；</li>
<li>将创建的文件移动到其他目录下；</li>
<li>创建 reparse point 及软链接，将原文件路径指向要删除的目标文件；</li>
<li>释放机会锁；</li>
</ol>
</li>
<li>主线程将目录 dir 的路径转换为 unc 格式，并通过 <code>CoCreateInstance</code> 的方式调用 sdrsvc 服务的 <code>CSdCommonImpl::QueryStorageDevice</code> 接口；</li>
<li>sdrsvc 服务在 unc 格式目录下创建临时文件，之后删除文件。</li>
</ol>
<p>如下图所示：</p>
<p><img src="/img/2023-01-17-18-41-08.png" alt=""></p>
<h2 id="5-小节">5. 小节</h2>
<p>到目前为止 CVE-2023-21752 这个漏洞本身其实已经分析完成了，但是漏洞利用部分还有很多内容没有学习：</p>
<ol>
<li>实现任意文件删除时，为何需要通过 Reparse point 的方式创建从临时文件到目标文件的链接；</li>
<li>如何由任意文件删除实现本地提权；</li>
<li>漏洞发现者提供的 exp 为何无法稳定复现，如何修复。</li>
</ol>
<p>过两天就放假了，暂时先告一段落，之后我会对这一部分内容进行学习。</p>
<h2 id="6-参考资料">6. 参考资料</h2>
<ol>
<li><a href="https://mp.weixin.qq.com/s/dhKtb8EeBwJnBEjepHXPpg">https://mp.weixin.qq.com/s/dhKtb8EeBwJnBEjepHXPpg</a></li>
<li><a href="https://googleprojectzero.blogspot.com/2018/08/windows-exploitation-tricks-exploiting.html">Windows Exploitation Tricks: Exploiting Arbitrary Object Directory Creation for Local Elevation of Privilege</a></li>
<li><a href="https://github.com/Wh04m1001/CVE-2023-21752">CVE-2023-21752 exp</a></li>
</ol>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/cve/" rel="tag">cve</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/binary/" rel="tag">binary</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="zoemurmure avatar" src="/img/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About zoemurmure</span>
	</div>
	<div class="authorbox__description">
		二进制安全研究菜鸟
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/csrss_base/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSRSS 基础知识</p>
		</a>
	</div>
</nav>




<section class="comments">
<script src="https://utteranc.es/client.js"
	repo="zoemurmure/zoemurmure.github.io"
	issue-term="pathname"
	theme="github-light"
	crossorigin="anonymous"
	async>
</script>
</section>



			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 Logic Security 逻辑门.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>