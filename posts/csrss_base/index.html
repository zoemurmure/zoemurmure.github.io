<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>CSRSS 基础知识 - Logic Security 逻辑门</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="csrss基础知识">
		<meta property="og:title" content="CSRSS 基础知识" />
<meta property="og:description" content="csrss基础知识" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.zoemurmure.top/posts/csrss_base/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-10T17:07:41+08:00" />
<meta property="article:modified_time" content="2023-01-10T17:07:41+08:00" />

		<meta itemprop="name" content="CSRSS 基础知识">
<meta itemprop="description" content="csrss基础知识"><meta itemprop="datePublished" content="2023-01-10T17:07:41+08:00" />
<meta itemprop="dateModified" content="2023-01-10T17:07:41+08:00" />
<meta itemprop="wordCount" content="1227">
<meta itemprop="keywords" content="os," />
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
<script async src="https://www.googletagmanager.com/gtag/js?id=G-CPJWE5ZVG9"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-CPJWE5ZVG9', { 'anonymize_ip': false });
}
</script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="Logic Security 逻辑门" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/img/blog_img.png">
				</div><div class="logo__item logo__text">
					<div class="logo__title">Logic Security 逻辑门</div>
					<div class="logo__tagline">欢迎关注同名微信公众号：逻辑门(*^_^*)</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">Home</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/history/">
				
				<span class="menu__text">历史文章</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CSRSS 基础知识</h1>
			<div class="post__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">zoemurmure</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2023-01-10T17:07:41&#43;08:00">2023-01-10</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="category">基础知识</a>
	</span>
</div></div>
		</header>
		
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#0-前言">0. 前言</a></li>
    <li><a href="#1-历史背景">1. 历史背景</a>
      <ul>
        <li><a href="#11-微内核microkernel的概念">1.1 微内核(microkernel)的概念</a></li>
        <li><a href="#12-win32-子系统">1.2 Win32 子系统</a></li>
      </ul>
    </li>
    <li><a href="#2-通信">2. 通信</a></li>
    <li><a href="#3-具体功能">3. 具体功能</a></li>
    <li><a href="#4-side-by-side">4. Side-by-side</a>
      <ul>
        <li><a href="#41-基本概念">4.1 基本概念</a></li>
        <li><a href="#42-manifest-清单">4.2 manifest (清单)</a></li>
        <li><a href="#43-activation-context-激活上下文">4.3 Activation context (激活上下文)</a></li>
      </ul>
    </li>
    <li><a href="#5-启动流程">5. 启动流程</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
	</div>
</div><div class="content post__content clearfix">
			<h2 id="0-前言">0. 前言</h2>
<p>这是一篇不完整的 csrss 介绍，因为前段时间在看 csrss 相关的漏送，所以对相关的知识做了一下整理，因此你无法只通过这篇文章完全了解 csrss，但是如果这篇文章能够解答你在学习 csrss 时的一些疑惑，那么它的目的就达成了。</p>
<h2 id="1-历史背景">1. 历史背景</h2>
<h3 id="11-微内核microkernel的概念">1.1 微内核(microkernel)的概念</h3>
<p>微内核指一个现代化、模块化操作系统中最核心的部分，微内核操作系统有两个原则：</p>
<ol>
<li>模块化、封装性和数据隐藏。即操作系统中有且仅有一部分对一个特定功能具有系统范围内的责任，操作系统中的其他部分，包括应用程序只能通过定义好的接口对使用该功能；</li>
<li>操作系统中的大部分功能在用户/应用程序模式下执行，只有微内核本身及硬件相关的小部分代码在内核态下执行。</li>
</ol>
<p>遵循以上两个原则的操作系统叫做纯微内核系统，仅遵循第一个原则但不遵循第二个原则的操作系统叫做修改后的微内核(modified microkernel)或者宏内核(macrokernel)操作系统。商业性质的操作系统一般不会基于纯微内核进行设计，因为这样的架构计算成本太大。</p>
<p>Windows NT 就是修改后的微内核系统，具有非常好的模块化和封装性，另一方面，从最初版本开始，Windows NT 就在内核态实现了高性能操作系统子系统，这些子系统可以在内核模式下与硬件交互以及相互交互，而不会影响处理器模式以及进程/线程转换的性能。作为内核态子系统实现的有内存管理器、集成缓存管理器、文件系统、对象/安全管理器、网络协议、网络服务器以及所有的线程/进程管理。</p>
<p>然而在 Windows NT 4.0 之前，有一个领域一直采取纯微内核模式，也就是窗口管理器以及图形化子系统，它们用于实现 Win32 API 中的 GUI 部分。在 Windows NT 3.51 及之前的版本中，窗口管理器和 GDI 作为一个单独的用户态进程 Client-Server Subsystem(csrss.exe) 实现。</p>
<h3 id="12-win32-子系统">1.2 Win32 子系统</h3>
<p>在 Windows NT 的最初设计阶段，Win32 被设计为等同于 OS/2、POSIX 以及其他计划中的操作系统环境。每个这样的子系统都作为一个独立的环境运行。但是这种设计会导致存在大量重复的系统功能，影响系统规模以及性能。为了避免重复，以及响应市场趋势，最终发布的 Windows NT 3.1 中，Win32 子系统成为一个特殊的特权“程序”，其他所有的子系统以及整个操作系统都依赖该程序。</p>
<p>在 Windows NT 4.0 之前，Win32 子系统包含 5 个模块，存在于不同 DLL 文件中：</p>
<ul>
<li>窗口管理器：处理输入以及屏幕 I/O；</li>
<li>图形设备接口(GDI)：图形输出设备的绘画库；</li>
<li>图形设备驱动(GDD)：硬件相关的图形驱动；</li>
<li>控制台：提供文字窗口支持；</li>
<li>操作系统功能：支持子系统中的所有组件。</li>
</ul>
<p>将图形功能放在单独的 Win32 服务器进程中会造成很大的内存开销以及大量的线程/进程上下文转换操作，极为影响系统性能。而 Windows NT 是一个基于窗口的操作系统，会有大量的图形和窗口操作，因此自 Windows NT 4.0 开始，设计团队将这部分常用的功能从用户态移入了内核态。</p>
<p>改变之后的系统中，窗口管理器、GDI 和 GDD 功能移入了内核态，即 win32k.sys，控制台、GUI 关闭以及硬错误处理功能仍然保留在用户态的 csrss.exe 中。</p>
<p>也就是说，在我们现在使用的操作系统中，csrss.exe + win32.sys 共同构成了 Win32 这个操作系统环境，而大多数人（包括我自己）都没有接触过 OS/2、 POSIX 等其他的操作系统环境，所以一开始理解 csrss.exe 的功能定位很困难。</p>
<h2 id="2-通信">2. 通信</h2>
<p>Windows 进程或线程启动时，以及任一 Windows 子系统的操作，都会使用 ALPC 与子系统进程 CSRSS 进行通信，所有和 会话管理器 SMSS 的子系统通信也通过 ALPC 进行。</p>
<p>ALPC，即高级（或异步）本地过程调用，是一种用于传递任意大小消息的高速、可扩展且安全的消息传递机制。一般用在一个服务器进程和多个该服务器的客户端进程之间。ALPC 连接可以建立在多个用户态进程间，也可以建立在一个内核态组件以及多个用户态进程之间，也可以建立在两个内核态组件之间。ALPC 使用一个叫做端口对象(port object)的执行对象来维护通信所需状态，该对象可以表示多种 ALPC 端口：</p>
<ul>
<li>服务器连接端口：作为服务器连接请求点的命名端口，客户端可以通过连接该端口连接服务器；</li>
<li>服务器通信端口：作为服务器与其中一个客户端通信的未命名端口，服务器为每个活跃的客户端提供一个这样的端口；</li>
<li>客户端通信端口：作为客户端与它的服务器通信的未命名端口；</li>
<li>未连接通信端口：作为客户端在本地与自己通信的未命名端口，该模型在从 LPC 发展到 ALPC 的过程中已经废弃了，但是由于兼容性问题，仍然为 Legacy LPC 模拟了该模型。</li>
</ul>
<p>ALPC 遵循类似 BSD 套接字编程的连接和通信模型。服务器先建立一个服务器连接端口(<code>NtAlpcCreatePort</code>)，客户端可以连接该端口(<code>NtAlpcConnectPort</code>)，如果服务器处于监听模式(<code>NtAlpcSendWaitReceivePort</code>)，就会接收到一个连接请求消息，并且可以选择接受该请求(<code>NtAlpcAcceptConnectPort</code>)。此时会建立客户端和服务器的通信端口，并且每个对应的端点进程会收到其通信端口的句柄，消息会通过该句柄进行传递(<code>NtAlpcSendWaitReceivePort</code>)。在最简单的情境下，一个单独的服务器会循环调用 <code>NtAlpcSendWaitReceivePort</code>，通过调用该函数接受连接请求或者处理/回复消息。服务器通过 <code>PORT_HEADER</code> 结构体对消息进行区分，该结构体位于每个消息的最外层，其中包含消息的类型。</p>
<p>一旦连接建立，会使用一个连接信息结构(blob)存储所有不同端口之间的链接。</p>
<p><img src="/img/2022-12-02-16-24-27.png" alt=""></p>
<p>在上面的描述中，客户端和服务器只能通过消息阻塞的方式轮流循环调用 <code>NtAlpcSendWaitReceivePort</code> 发送请求并等待响应。但实际上 ALPC 也支持异步消息，这样通信双方就不需要进行阻塞，而可以选择执行其他任务并在之后对消息进行检查。ALPC 支持以下消息交换的方式：</p>
<ul>
<li>标准的双缓冲机制。内核通过从源进程复制的方式保留一份消息拷贝，然后转换到目标进程，从内核缓冲区中复制数据。出于兼容性考虑，如果使用的是旧版 LPC，这种方式最多发送 256 字节的消息，而 ALPC 可以为最大 64 KB 的消息分配扩展缓冲区；</li>
<li>将消息保存在 ALPC section object 中，客户端和服务器通过映射视图对消息进行处理；</li>
</ul>
<p>在异步消息的模式下，消息可以被取消，例如请求花费时间过长，或者用户表示要取消之前的操作。在 ALPC 中可以使用 <code>NtAlpcCancelMessage</code> 系统调用取消消息。</p>
<p>一个 ALPC 消息可以位于以下五种由 ALPC 端口对象实现的队列中：</p>
<ul>
<li>主队列：消息已被发出，客户端正在处理；</li>
<li>等待队列：消息已被发出，发送方等待响应，但是响应还未发出；</li>
<li>大消息队列：消息已被发出，但是发送方缓冲区太小无法容纳该消息，此时发送方有机会分配一个更大的缓冲区并再次请求该消息；</li>
<li>取消队列：消息发送到该端口，但是已经被取消；</li>
<li>直接队列：发送时附加了直接事件的消息。</li>
</ul>
<h2 id="3-具体功能">3. 具体功能</h2>
<p>通过在 Process Hacker 中查看 csrss.exe 加载的模块名称，可以发现 csrss 功能涉及到的 DLL 文件有：basesrv.dll(Windows NT BASE API Server DLL)、winsrv.dll(Multi-User Windows Server DLL)、csrsrv.dll(Client Server Runtime Process)、sxssrv.dll(Windows SxS Server DLL)、sxs.dll。总结这些文件中包含的 <code>ServerApiDispatchTable</code> 以及导出函数：</p>
<pre tabindex="0"><code>              |  basesrv.dll                   | winsrv.dll                 | csrsrv.dll                  | sxssrv.dll | sxs.dll |
----------------------------------------------------------------------------------------------------------------------------------
              | BaseSrvCreateProcess           |                            |                             |            |         |
              | BaseSrvDeadEntry               |                            |                             |            |         |
              | BaseSrvCheckVDM                |                            |                             |            |         |
              | BaseSrvUpdateVDMEntry          |                            |                             |            |         |
              | BaseSrvGetNextVDMCommand       |                            |                             |            |         |
              | BaseSrvExitVDM                 |                            |                             |            |         |
              | BaseSrvIsFirstVDM              |                            |                             |            |         |
              | BaseSrvGetVDMExitCode          |                            |                             |            |         |
              | BaseSrvSetReenterCount         |                            |                             |            |         |
              | BaseSrvSetProcessShutdownParam |                            |                             |            |         |
              | BaseSrvGetProcessShutdownParam |                            |                             |            |         |
              | BaseSrvSetVDMCurDirs           |                            |                             |            |         |
Dispatch Table| BaseSrvGetVDMCurDirs           | SrvEndTask                 | CsrSrvClientConnect         |            |         |
              | BaseSrvBatNotification         |                            |                             |            |         |
              | BaseSrvRegisterWowExec         |                            |                             |            |         |
              | BaseSrvSoundSentryNotification |                            |                             |            |         |
              | BaseSrvRefreshIniFileMapping   |                            |                             |            |         |
              | BaseSrvDefineDosDevice         |                            |                             |            |         |
              | BaseSrvSetTermsrvAppInstallMode|                            |                             |            |         |
              | BaseSrvSetTermsrvClientTimeZone|                            |                             |            |         |
              | BaseSrvCreateActivationContext |                            |                             |            |         |
              | BaseSrvRegisterThread          |                            |                             |            |         |
              | BaseSrvDeferredCreateProcess   |                            |                             |            |         |
              | BaseSrvNlsGetUserInfo          |                            |                             |            |         |
              | BaseSrvNlsUpdateCacheCount     |                            |                             |            |         |
              | BaseSrvCreateProcess2          |                            |                             |            |         |
              | BaseSrvCreateActivationContext2|                            |                             |            |         |
----------------------------------------------------------------------------------------------------------------------------------
              |                                |                            | CsrAddStaticServerThread    |            |         |
              |                                |                            | CsrCallServerFromServer     |            |         |
              |                                |                            | CsrConnectToUser            |            |         |
              |                                |                            | CsrCreateProcess            |            |         |
              |                                |                            | CsrCreateRemoteThread       |            |         |
              |                                |                            | CsrCreateThread             |            |         |
              |                                |                            | CsrDeferredCreateProcess    |            |         |
              |                                |                            | CsrDereferenceProcess       |            |         |
              |                                |                            | CsrDereferenceThread        |            |         |
              |                                |                            | CsrDestroyProcess           |            |         |
              |                                |                            | CsrDestroyThread            |            |         |
              |                                |                            | CsrExecServerThread         |            |         |
              | BaseGetProcessCrtlRoutine      |                            | CsrGetProcessLuid           |            |         |
              | BaseSetProcessCreateNotify     | SrvEndTask                 | CsrImpersonateClient        |            |         |
              | BaseSrvNlsLogon                | UserCreateCallbackThread   | CsrIsClientSandboxed        |            |         |
Export Func   | BaseSrvNlsUpdateRegistryCache  | UserHardError              | CsrLockProcessByClientId    |            |         |
              | BaseSrvRegisterSxS             | UserServerDllInitialization| CsrLockThreadByClientId     |            |         |
              | ServerDllInitialization        |                            | CsrLockedReferenceProcess   |            |         |
              |                                |                            | CsrQueryApiPort             |            |         |
              |                                |                            | CsrReferenceThread          |            |         |
              |                                |                            | CsrRegisterClientThreadSetup|            |         |
              |                                |                            | CsrReplyToMessage           |            |         |
              |                                |                            | CsrRevertToSelf             |            |         |
              |                                |                            | CsrServerInitialization     |            |         |
              |                                |                            | CsrSetBackgroundPriority    |            |         |
              |                                |                            | CsrSetForegroundPriority    |            |         |
              |                                |                            | CsrShutdownProcesses        |            |         |
              |                                |                            | CsrUnhandledExceptionFilter |            |         |
              |                                |                            | CsrUnlockProcess            |            |         |
              |                                |                            | CsrUnlockThread             |            |         |
              |                                |                            | CsrValidateMessageBuffer    |            |         |
              |                                |                            | CsrValidateMessageString    |            |         |
----------------------------------------------------------------------------------------------------------------------------------
</code></pre><p>Windows Vista 及之后的系统中会存在多个 csrss.exe 进程，其中一个 csrss.exe 进程由 Session Manager(smss.exe) 在系统启动时创建，负责处理来自 session-0 模块的请求，并存在于整个系统生命周期，如果该进程崩溃，则整个系统崩溃；其余 csrss.exe 进程在某用户登录时由 smss.exe 创建，负责处理来自该用户会话下应用程序的请求，并存在于该用户登录期间，进程崩溃不会导致系统崩溃。所有 csrss.exe 进程都具有最高用户权限 NT AUTHORITY\SYSTEM。</p>
<pre tabindex="0"><code>1: kd&gt; dt csrss!_csr_process 
   +0x000 ClientId         : _CLIENT_ID
   +0x010 ListLink         : _LIST_ENTRY
   +0x020 ThreadList       : _LIST_ENTRY
   +0x030 NtSession        : Ptr64 _CSR_NT_SESSION
   +0x038 ClientPort       : Ptr64 Void
   +0x040 ClientViewBase   : Ptr64 Char
   +0x048 ClientViewBounds : Ptr64 Char
   +0x050 ProcessHandle    : Ptr64 Void
   +0x058 SequenceNumber   : Uint4B
   +0x05c Flags            : Uint4B
   +0x060 DebugFlags       : Uint4B
   +0x064 ReferenceCount   : Int4B
   +0x068 ProcessGroupId   : Uint4B
   +0x06c ProcessGroupSequence : Uint4B
   +0x070 LastMessageSequence : Uint4B
   +0x074 NumOutstandingMessages : Uint4B
   +0x078 ShutdownLevel    : Uint4B
   +0x07c ShutdownFlags    : Uint4B
   +0x080 Luid             : _LUID
   +0x088 ServerDllPerProcessData : [1] Ptr64 Void
</code></pre><h2 id="4-side-by-side">4. Side-by-side</h2>
<p>上面的 sxssrv.dll 和 sxs.dll 和 Windows 的 Side-by-side 功能有关，这里学习一下 sxs。</p>
<h3 id="41-基本概念">4.1 基本概念</h3>
<p>在不使用 sxs 功能的一般情况下，一个程序要加载它需要的 DLL 文件，需要按照以下顺序搜索 DLL 文件名：</p>
<ul>
<li>被加载应用程序所在目录</li>
<li>native Windows 系统目录 (<code>C:\Windows\System32</code>)</li>
<li>16-bit Windows 系统目录 (<code>C:\Windows\System</code>)</li>
<li>Windows 目录 (<code>C:\Windows</code>)</li>
<li>应用程序加载时的当前目录</li>
<li><code>%PATH</code> 环境变量中指定目录</li>
</ul>
<p>这种加载方式很容易带来安全问题，为此 Windows 也提供了很多种机制进行防护，这里不再列举。</p>
<p>考虑更复杂的情况，由于 DLL 文件中的功能会出于安全、性能等原因进行修改，DLL 文件的版本会更新，但是开发者开发的程序要求可能比较苛刻，只能使用某版本 DLL 文件中提供的功能，在这种情况下，应用程序需要有一种方式指定使用某版本的 DLL 文件，同时 Windows 也需要以某种机制向该程序提供该版本的 DLL 文件。为此，引入了 side-by-side assembly 这一概念。</p>
<p>根据 MSDN, 程序集 (assembly) 是用于命名、绑定、版本控制、部署或配置编程代码块的基本单元。具有常见功能的应用程序可能会运行共享的编程代码块，这些代码块叫做模块或者代码程序集，代码程序集可能被放在 DLL 文件或者 COM 程序集中。用于程序集安全共享的基础结构就叫做 side-by-side 程序集共享。一个典型的 side-by-side assembly 就是一个单独的 DLL 文件加上一个单独的 manifest。Manifest 中包含了用于描述 side-by-side asembly 及其依赖的元数据。</p>
<p>上面的解释在第一次接触的时候其实比较抽象，我在学习的时候直接把 assembly 当作是 DLL 文件的另一种叫做，都是一个<strong>某一通用功能相关代码的集合</strong>。</p>
<p>sxs 程序集有私人的，也有共享的，Windows 的共享程序集保存在 <code>C:\Windows\Winsxs</code> 目录下。如果应用程序想要使用 sxs 功能，需要提供一个 manifest 文件，里面包含了 DLL 文件的版本信息，这样系统在加载 DLL 文件的时候，就会根据 manifest 中的内容，首先在 Winsxs 目录下进行搜索。</p>
<h3 id="42-manifest-清单">4.2 manifest (清单)</h3>
<p>程序集清单实际上是一个 XML 文件</p>
<h3 id="43-activation-context-激活上下文">4.3 Activation context (激活上下文)</h3>
<p>manifest 保存在二进制文件的资源段中，系统加载 manifest 内容的时候，会将这些依赖信息打包成一个叫做 activation context 的搜索结构中。</p>
<p>系统会在引导以及进程启动的时候对应创建系统和进程级别的默认激活上下文，除此之外，每个线程也会有一个关联的激活上下文栈，栈顶部的激活上下文结构是当前活跃的。每个线程的激活上下文栈可以通过函数 <code>ActivateActCtx</code> 和 <code>DeactivateActCtx</code> 显示管理，也可以通过系统在某个时间点进行隐式管理，例如当一个带有依赖信息的二进制文件的 DLL 主例程被调用的时候。</p>
<p>系统在解析 DLL 文件路径的时候，会首先查找当前线程激活上下文栈顶部的激活上下文内容，如果没找到，再依次查找进程和系统的激活上下文。</p>
<h2 id="5-启动流程">5. 启动流程</h2>
<p>启动参数：</p>
<pre tabindex="0"><code>%SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,20480,768 Windows=On SubSystemType=Windows ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3 ServerDll=sxssrv,4 ProfileControl=Off MaxRequestThreads=16
</code></pre><p>IDA 查看 csrss.exe，它会调用位于 csrsrv.dll 中的 <code>CsrServerInitialization</code> 函数，该函数会调用 <code>CsrParseServerCommandLine</code>，找到其中的 <code>!_stricmp(name, &quot;ServerDLL&quot;)</code>，可以看到当参数为 <code>ServerDLL=</code> 时，函数会根据冒号以及逗号对参数值做分割，并调用 <code>result = CsrLoadServerDll(value_idx, func_name, num);</code> 加载对应 DLL 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>_stricmp(name, <span style="color:#e6db74">&#34;ServerDLL&#34;</span>) )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        cur_char_1 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>value_idx;
</span></span><span style="display:flex;"><span>        func_name <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>i64;
</span></span><span style="display:flex;"><span>        idx_1 <span style="color:#f92672">=</span> value_idx;
</span></span><span style="display:flex;"><span>        v8 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xC000000D</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!*</span>value_idx )
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> v8;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> ( <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ( cur_char_1 <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;:&#39;</span> )
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            cur_char_1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;:&#39;</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>func_name )
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">*</span>idx_1<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>              func_name <span style="color:#f92672">=</span> idx_1;
</span></span><span style="display:flex;"><span>              cur_char_1 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>idx_1;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">++</span>idx_1;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ( cur_char_1 <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;,&#39;</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>          cur_char_1 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>idx_1;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!*</span>idx_1 )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> v8;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        v8 <span style="color:#f92672">=</span> RtlCharToInteger(idx_1, <span style="color:#ae81ff">0xAu</span>, <span style="color:#f92672">&amp;</span>num);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( v8 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> v8;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>(idx_1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> CsrLoadServerDll(value_idx, func_name, num);
</span></span><span style="display:flex;"><span>        v8 <span style="color:#f92672">=</span> result;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( result <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      ...
</span></span></code></pre></div><p><code>CsrLoadServerDll</code> 构造了一个新的结构体，这里暂且叫做 <code>ServerDllStruct</code>，并以此为参数调用了对应 DLL 文件中的 <code>func_name</code> 函数，如果 <code>func_name</code> 没有指定，就调用 <code>ServerDllInitialization</code> 函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>v7 <span style="color:#f92672">=</span> dll_name_2.MaximumLength <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x78</span>;
</span></span><span style="display:flex;"><span>heap <span style="color:#f92672">=</span> RtlAllocateHeap(CsrHeap, CsrBaseTag <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40000</span>, v7);
</span></span><span style="display:flex;"><span>server_dll_struct <span style="color:#f92672">=</span> heap;
</span></span><span style="display:flex;"><span>Parameters[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> heap;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ( heap )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  memset_0(heap, <span style="color:#ae81ff">0</span>, v7);
</span></span><span style="display:flex;"><span>  server_dll_struct<span style="color:#f92672">-&gt;</span>pCsrSrvSharedSectionHeap <span style="color:#f92672">=</span> CsrSrvSharedSectionHeap;
</span></span><span style="display:flex;"><span>  server_dll_struct<span style="color:#f92672">-&gt;</span>NameLength <span style="color:#f92672">=</span> dll_name_2.Length;
</span></span><span style="display:flex;"><span>  server_dll_struct<span style="color:#f92672">-&gt;</span>NameMaximumLength <span style="color:#f92672">=</span> dll_name_2.MaximumLength;
</span></span><span style="display:flex;"><span>  server_dll_struct<span style="color:#f92672">-&gt;</span>pName <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>server_dll_struct[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( dll_name_2.Length )
</span></span><span style="display:flex;"><span>    strncpy_s(<span style="color:#f92672">&amp;</span>server_dll_struct[<span style="color:#ae81ff">1</span>], server_dll_struct<span style="color:#f92672">-&gt;</span>NameMaximumLength, dll_name_2.Buffer, dll_name_2.Length);
</span></span><span style="display:flex;"><span>  server_dll_struct<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> num;
</span></span><span style="display:flex;"><span>  server_dll_struct<span style="color:#f92672">-&gt;</span>pAddress <span style="color:#f92672">=</span> dll_addr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( dll_addr )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( func_name )
</span></span><span style="display:flex;"><span>      func_name_1 <span style="color:#f92672">=</span> func_name;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      func_name_1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ServerDllInitialization&#34;</span>;
</span></span><span style="display:flex;"><span>    RtlInitString(<span style="color:#f92672">&amp;</span>func_name_2, func_name_1);
</span></span><span style="display:flex;"><span>    status_1 <span style="color:#f92672">=</span> LdrGetProcedureAddress(dll_addr, <span style="color:#f92672">&amp;</span>func_name_2, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>func_addr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( status_1 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v15 <span style="color:#f92672">=</span> dll_addr;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>dll_addr )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> LABEL_35;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> LABEL_34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    v12 <span style="color:#f92672">=</span> (func_addr)(server_dll_struct);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    func_addr <span style="color:#f92672">=</span> CsrServerDllInitialization;
</span></span><span style="display:flex;"><span>    v12 <span style="color:#f92672">=</span> (CsrServerDllInitialization)(server_dll_struct);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  status_1 <span style="color:#f92672">=</span> v12;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( v12 <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    LODWORD(CsrTotalPerProcessDataLength) <span style="color:#f92672">=</span> ((server_dll_struct<span style="color:#f92672">-&gt;</span>num3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFF8</span>)
</span></span><span style="display:flex;"><span>                                          <span style="color:#f92672">+</span> CsrTotalPerProcessDataLength;
</span></span><span style="display:flex;"><span>    v13 <span style="color:#f92672">=</span> server_dll_struct<span style="color:#f92672">-&gt;</span>value;
</span></span><span style="display:flex;"><span>    CsrLoadedServerDll[v13] <span style="color:#f92672">=</span> server_dll_struct;
</span></span><span style="display:flex;"><span>    v14 <span style="color:#f92672">=</span> server_dll_struct<span style="color:#f92672">-&gt;</span>pCsrSrvSharedSectionHeap;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( v14 <span style="color:#f92672">!=</span> CsrSrvSharedSectionHeap )
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">*</span>(v13 <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">+</span> CsrSrvSharedStaticServerData) <span style="color:#f92672">=</span> v14;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> status_1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>根据以上代码判断，在 csrss.exe 的启动参数中，<code>ServerDLL</code> 数值中各字段意义为：<code>ServerDll=[Dll文件名]:[函数名],[对应ServerDllStruct索引值]</code></p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="http://www.pkuexploit.com/files/paper50.pdf">基于Windows的CSRSS进程漏洞分析与利用</a></li>
<li><a href="https://bbs.pediy.com/thread-150284.htm">csrss进程剖析</a></li>
<li><a href="https://j00ru.vexillium.org/2010/07/windows-csrss-write-up-the-basics/">Windows CSRSS write up: the basics (part 1/1)</a></li>
<li><a href="https://j00ru.vexillium.org/?p=502">Windows CSRSS Write Up: Inter-process Communication (part 1/3)</a></li>
<li><a href="https://j00ru.vexillium.org/?p=527">Windows CSRSS Write Up: Inter-process Communication (part 2/3)</a></li>
<li><a href="https://learn.microsoft.com/en-us/previous-versions//cc750820(v=technet.10)?redirectedfrom=MSDN#XSLTsection124121120120">MS Windows NT Kernel-mode User and GDI White Paper</a></li>
</ol>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/os/" rel="tag">os</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="zoemurmure avatar" src="/img/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About zoemurmure</span>
	</div>
	<div class="authorbox__description">
		二进制安全研究菜鸟，微信公众号：逻辑门
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/x64_paging/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">X64 分页机制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cve_2023_21752_1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[CVE-2023-21752] Windows Backup Service 本地提权漏洞分析</p>
		</a>
	</div>
</nav>




<section class="comments">
<script src="https://utteranc.es/client.js"
	repo="zoemurmure/zoemurmure.github.io"
	issue-term="pathname"
	theme="github-light"
	crossorigin="anonymous"
	async>
</script>
</section>



			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 Logic Security 逻辑门.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>